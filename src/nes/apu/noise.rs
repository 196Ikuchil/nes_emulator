use super::constants::*;
use super::super::types::{Data, Addr};

#[derive(Debug)]
pub struct Noise {
  // 0x00c
  is_length_counter_enabled: bool, // F-> enable loop
  is_envelope_enabled: bool,
  envelope_period_and_volume: usize,
  // 0x0e
  mode_flag: bool,
  timer_period: usize,
  // 0x0f
  length_counter: usize,

  shift_register: u16,
  is_envelope_start: bool,
  envelope_generator_counter: usize,
  envelope_volume: usize,
  timer_counter: usize,
  enabled: bool,
}

extern "C" {
  fn set_noise_frequency(freq: f32);
  fn set_noise_volume(volume: f32);
  fn stop_noise();
  fn start_noise();
}

impl Noise {
  pub fn new() -> Self {
    Noise {
      is_length_counter_enabled: false,
      is_envelope_enabled: false,
      envelope_period_and_volume: 0x0F,
      mode_flag: false, // T->short, F->long
      timer_period: 0x00,
      length_counter: 0x00,

      shift_register: 0x01,
      is_envelope_start: false,
      envelope_generator_counter: 0,
      envelope_volume: 0,
      timer_counter: 0,
      enabled: false,
    }
  }

  pub fn write(&mut self, addr: Addr, data: Data) {
    match addr {
      0x00 => {
        self.is_length_counter_enabled = data & 0x20 == 0x00;
        self.is_envelope_enabled = data & 0x10 == 0x00;
        self.envelope_period_and_volume = data as usize & 0x0F;
        self.is_envelope_start = true;
        self.set_volume();
      }
      0x02 => {
        self.mode_flag = data & 0x80 == 0x80;
        self.set_frequency(data);
        self.timer_period = data as usize & 0x0F; //timer period. current not uesd. it is used in step timer.
      }
      0x03 => {
        self.length_counter = COUNTER_TABLE[(data as usize & 0xF8) >> 3] as usize;
        self.is_envelope_start = true;
        self.set_volume();
      }
      _ => ()
    }
  }

  pub fn start(&self) {
    // unsafe { start_noise() };
  }

  pub fn stop(&self) {
      unsafe { stop_noise() };
  }

  pub fn enable(&mut self) {
    self.enabled = true;
    self.start();
  }

  pub fn disable(&mut self) {
      self.enabled = false;
      self.stop();
  }

  fn set_volume(&self) {
    unsafe {
      set_noise_volume(self.get_volume())
    }
  }

  pub fn has_count_end(&self) -> bool {
    self.length_counter == 0
  }

  fn get_volume(&self) -> f32 {
    // let vol = if !self.enabled || self.length_counter == 0 || self.shift_register & 0x01 == 0x01 {
    //   0
    let vol = if !self.enabled || self.length_counter == 0 {
      0
    } else{
      if self.is_envelope_enabled {
        self.envelope_volume
      } else {
        self.envelope_period_and_volume
      }
    };
    vol as f32 / (GROBAL_GAIN)
  }

  fn set_frequency(&self, data: Data) {
    unsafe {
      set_noise_frequency(CPU_CLOCK as f32 /
                            NOISE_TIMER_PERIOD_TABLE[data as usize & 0x0F] as f32 /
                            2f32); //?
    }
  }
  // step envelope
  pub fn update_envelope(&mut self) {
    self.step_envelope();
    self.set_volume();
  }

  // step length
  pub fn update_counter(&mut self) {
    self.step_length();
  }

  // not use.
  // shift_register used to random generator.
  // current random noise generated by WebAudio
  pub fn step_timer(&mut self) {
    if self.timer_counter == 0 {
      self.timer_counter = self.timer_period;
      let shift = if self.mode_flag {
        6
      } else {
        1
      };
      let b1 = self.shift_register & 0x01;
      let b2 = (self.shift_register >> shift) & 0x01;
      self.shift_register >>= shift;
      self.shift_register |= (b1^b2) << 14
    } else {
      self.timer_counter -= 1;
    }
  }

  fn step_envelope(&mut self) {
    if self.is_envelope_start {
      self.envelope_volume = 0x0F;
      self.envelope_generator_counter = self.envelope_period_and_volume;
      self.is_envelope_start = false
    } else if self.envelope_generator_counter > 0 {
      self.envelope_generator_counter -= 1;
    } else {
      if self.envelope_volume > 0 {
        self.envelope_volume -= 1;
      } else if !self.is_length_counter_enabled {
        self.envelope_volume = 0x0F;
        self.stop();
      }
      self.envelope_generator_counter = self.envelope_period_and_volume;
    }
  }

  fn step_length(&mut self) {
    if self.is_length_counter_enabled && self.length_counter > 0 {
      self.length_counter -= 1;
    }
  }
}